import * as FileSystem from 'expo-file-system';
import { Asset } from 'expo-asset';
import { Platform } from 'react-native';
import { dailyScriptures, emergencyScriptures, getRandomScripture, ScriptureVerse } from './scriptureLists';
import { 
  openBibleDatabase, 
  Database, 
  executeSql,
  verifyDatabaseIntegrity
} from './bibleDatabaseUtils';
import * as SQLite from 'expo-sqlite';

// Define custom SQLite types - these are also exported from bibleDatabaseUtils
type SQLiteTransaction = any;
type SQLiteResultSet = any;
type SQLiteError = any;

// Define types for Bible database
export interface BibleBook {
  id: number;
  name: string;
}

export interface BibleVerse {
  id: number;
  book_id: number;
  chapter: number;
  verse: number;
  text: string;
  book_name?: string; // Used when joining with books table
}

export interface Scripture {
  book_name: string;
  chapter: number;
  verse: number;
  text: string;
}

// Add these types to help with database structure detection
export interface DatabaseTableInfo {
  name: string;
}

export interface DatabaseTableSchema {
  name: string;
  columns: string[];
}

export interface DetectedDatabaseStructure {
  booksTable: string | null;
  versesTable: string | null;
  translation: string | null;
}

const DATABASE_NAME = 'KJV.db';
const DATABASE_ASSET_PATH = '../assets/db/KJV.db';

let db: Database | null = null;

// Define essential verses for fallback when full database can't be loaded
const essentialVerses = [
  // Genesis key passages
  { id: 101, book_id: 1, chapter: 1, verse: 1, text: 'In the beginning God created the heaven and the earth.' },
  // John 3:16 - most known verse
  { id: 126, book_id: 43, chapter: 3, verse: 16, text: 'For God so loved the world, that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life.' },
  // Romans salvation
  { id: 128, book_id: 45, chapter: 3, verse: 23, text: 'For all have sinned, and come short of the glory of God;' },
  { id: 130, book_id: 45, chapter: 6, verse: 23, text: 'For the wages of sin is death; but the gift of God is eternal life through Jesus Christ our Lord.' },
  // Psalm 23
  { id: 108, book_id: 19, chapter: 23, verse: 1, text: 'The LORD is my shepherd; I shall not want.' },
  // Isaiah 53:5
  { id: 115, book_id: 23, chapter: 53, verse: 5, text: 'But he was wounded for our transgressions, he was bruised for our iniquities: the chastisement of our peace was upon him; and with his stripes we are healed.' },
  // Philippians 4:13
  { id: 136, book_id: 50, chapter: 4, verse: 13, text: 'I can do all things through Christ which strengtheneth me.' },
  // Proverbs 3:5-6
  { id: 112, book_id: 20, chapter: 3, verse: 5, text: 'Trust in the LORD with all thine heart; and lean not unto thine own understanding.' },
  { id: 113, book_id: 20, chapter: 3, verse: 6, text: 'In all thy ways acknowledge him, and he shall direct thy paths.' },
  // Matthew 28:19-20
  { id: 123, book_id: 40, chapter: 28, verse: 19, text: 'Go ye therefore, and teach all nations, baptizing them in the name of the Father, and of the Son, and of the Holy Ghost:' },
];

// Add these declarations near the top of the file, after imports
const tempDbPath = `${(FileSystem as any).documentDirectory}raw_extract_temp.db`;
const tempDbName = 'raw_extract_temp.db';

// Main function to get database instance
export async function getDatabase(): Promise<Database> {
  try {
    // Get database instance
    const db = await openBibleDatabase();
    
    // Verify required tables exist
    const result = await executeSql(
      db,
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='KJV_books' OR name='KJV_verses')"
    );
    
    const tables = result.rows._array.map(row => row.name);
    if (!tables.includes('KJV_books') || !tables.includes('KJV_verses')) {
      console.warn('Required tables not found, attempting emergency initialization...');
      await emergencyDatabaseInit();
      return getDatabase(); // Retry after emergency init
    }
    
    // Verify we have data
    const countResult = await executeSql(
      db,
      "SELECT (SELECT COUNT(*) FROM KJV_books) as book_count, (SELECT COUNT(*) FROM KJV_verses) as verse_count"
    );
    
    const { book_count, verse_count } = countResult.rows._array[0];
    console.log(`KJV database loaded with ${book_count} books and ${verse_count} verses`);
    
    if (book_count < 66 || verse_count < 31000) {
      console.warn(`KJV database appears incomplete: ${book_count} books, ${verse_count} verses`);
      await emergencyDatabaseInit();
      return getDatabase(); // Retry after emergency init
    }
    
    return db;
  } catch (error) {
    console.error('Error in getDatabase:', error);
    throw error;
  }
}

// Initialize the Bible database
export const initBibleDatabase = async (): Promise<boolean> => {
  try {
    console.log('Initializing Bible database...');
    
    // If we already have a db instance, close it
    if (db) {
      await db.closeAsync();
      db = null;
    }

    // Ensure the database directory exists
    await FileSystem.makeDirectoryAsync(FileSystem.documentDirectory!, { intermediates: true }).catch(() => {});
    
    const dbPath = `${FileSystem.documentDirectory}${DATABASE_NAME}`;
    const dbExists = await FileSystem.getInfoAsync(dbPath);
    
    // If database doesn't exist or is empty, copy from asset
    if (!dbExists.exists || dbExists.size === 0) {
      console.log('Database not found, copying from asset...');
      const asset = Asset.fromModule(require(DATABASE_ASSET_PATH));
      await asset.downloadAsync();
      
      if (!asset.localUri) {
        throw new Error('Failed to get local URI for KJV database asset');
      }
      
      await FileSystem.copyAsync({
        from: asset.localUri,
        to: dbPath
      });
    }
    
    // Open the database
    db = await openBibleDatabase(DATABASE_NAME);
    
    // Verify required tables exist
    const result = await executeSql(
      db,
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='KJV_books' OR name='KJV_verses')"
    );
    
    const tables = result.rows._array.map((row: { name: string }) => row.name);
    if (!tables.includes('KJV_books') || !tables.includes('KJV_verses')) {
      throw new Error('Required tables not found in KJV database');
    }
    
    // Verify we have data
    const countResult = await executeSql(
      db,
      "SELECT (SELECT COUNT(*) FROM KJV_books) as book_count, (SELECT COUNT(*) FROM KJV_verses) as verse_count"
    );
    
    const { book_count, verse_count } = countResult.rows._array[0];
    console.log(`KJV database loaded with ${book_count} books and ${verse_count} verses`);
    
    if (book_count < 66 || verse_count < 31000) {
      throw new Error('KJV database appears incomplete');
    }
    
    return true;
  } catch (error) {
    console.error('Bible database initialization error:', error);
    return false;
  }
};

// Initialize the database tables
const initDatabase = async (db: Database): Promise<void> => {
  try {
    console.log('Creating Bible tables if they don\'t exist...');
    
    // Use the direct execAsync method first
    const tablesCreated = await createTablesWithExec(db);
    
    if (!tablesCreated) {
      console.error('Failed to create tables with execAsync, trying transaction approach...');
      
      // Try the transaction approach as fallback
      try {
        console.log('Attempting to create tables in a transaction...');
        await db.withTransactionAsync(async () => {
          // Create books table
          await executeSql(db, `
            CREATE TABLE IF NOT EXISTS kjv_books (
              id INTEGER PRIMARY KEY,
              name TEXT NOT NULL
            )
          `);
          
          // Create verses table
          await executeSql(db, `
            CREATE TABLE IF NOT EXISTS kjv_verses (
              id INTEGER PRIMARY KEY,
              book_id INTEGER NOT NULL,
              chapter INTEGER NOT NULL,
              verse INTEGER NOT NULL,
              text TEXT NOT NULL,
              FOREIGN KEY (book_id) REFERENCES kjv_books (id)
            )
          `);
          
          // Create search index
          await executeSql(db, `
            CREATE INDEX IF NOT EXISTS idx_verses_book_chapter ON kjv_verses (book_id, chapter);
          `);
        });
        console.log('Tables created successfully using transaction');
      } catch (transactionError) {
        console.error('Error creating tables with transaction:', transactionError);
        console.log('Falling back to individual table creation...');
        
        // If transaction approach fails, try creating tables one by one
        await createBibleTables(db);
      }
    }
    
    // Verify tables were created
    const tablesResult = await executeSql(
      db,
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='kjv_books' OR name='kjv_verses')",
      []
    );
    
    const tables = tablesResult.rows._array.map((row: { name: string }) => row.name);
    console.log('Tables in database after initialization:', tables);
    
    if (!tables.includes('kjv_books') || !tables.includes('kjv_verses')) {
      console.error('Tables were not created successfully, tables found:', tables);
      throw new Error('Failed to create required database tables');
    }
    
    console.log('Database initialization completed successfully');
  } catch (error) {
    console.error('Error initializing database tables:', error);
    throw error;
  }
};

// Check if database is populated
export const isDatabasePopulated = async (): Promise<boolean> => {
  try {
    const db = await getDatabase();
    const result = await executeSql(db, 'SELECT COUNT(*) as count FROM kjv_books');
    const count = result.rows._array[0]?.count || 0;
    return count > 0;
  } catch (error) {
    console.error('Error checking if database is populated:', error);
    return false;
  }
};

/**
 * Count the total number of verses in the database
 */
export const getVersesCount = async (): Promise<number> => {
  try {
    const db = await getDatabase();
    const result = await executeSql(
      db,
      `SELECT COUNT(*) as count FROM kjv_verses`,
      []
    );
    
    if (result.rows.length > 0) {
      return result.rows._array[0].count;
    }
    return 0;
  } catch (error) {
    console.error('Error counting verses:', error);
    return 0;
  }
};

/**
 * Get standard verse count for a chapter based on the book and chapter number
 */
export const getStandardVerseCount = (bookId: number, chapter: number): number => {
  // Notable chapters with special verse counts
  const specialChapters: Record<string, number> = {
    // Genesis
    '1-1': 31, // Genesis 1 has 31 verses
    '1-2': 25, // Genesis 2 has 25 verses
    // Psalms
    '19-119': 176, // Psalm 119 has 176 verses (longest chapter)
    '19-117': 2,   // Psalm 117 has 2 verses (shortest chapter)
    // John
    '43-3': 36,    // John 3 has 36 verses (includes John 3:16)
    // Revelation
    '66-22': 21,   // Revelation 22 has 21 verses
  };

  const key = `${bookId}-${chapter}`;
  if (specialChapters[key]) {
    return specialChapters[key];
  }

  // Default verse counts based on typical chapter lengths
  switch (bookId) {
    case 19: // Psalms - generally longer chapters
      return 25;
    case 20: // Proverbs
    case 23: // Isaiah
      return 22;
    case 66: // Revelation
      return 20;
    default:
      return 30; // Default average chapter length
  }
};

// Type-safe access to rows from SQLite results
const getRowsData = (results: SQLiteResultSet): any[] => {
  if (results.rows && results.rows._array) {
    return results.rows._array;
  } else if (results.rows && typeof results.rows.item === 'function') {
    const data = [];
    for (let i = 0; i < results.rows.length; i++) {
      data.push(results.rows.item(i));
    }
    return data;
  } else if (results.rows) {
    return Array.from(results.rows as any);
  }
  return [];
};

// This function detects the database structure dynamically
export const detectDatabaseStructure = async (db: Database): Promise<DetectedDatabaseStructure> => {
  try {
    console.log('Detecting database structure...');
    // Get all tables in the database - use a more robust query that works across all SQLite versions
    const tableListQuery = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE 'android_%'";
    
    // We'll add additional debugging and robustness
    let tableResults;
    try {
      tableResults = await executeSql(db, tableListQuery, []);
      console.log('Raw table results:', JSON.stringify(tableResults));
    } catch (error) {
      console.error('Error executing table list query:', error);
      throw new Error('Failed to query database tables');
    }
    
    // Use our helper for consistent access to rows
    const tableData = getRowsData(tableResults);
    const tables: string[] = tableData.map(row => row.name).filter(Boolean);
    
    console.log('Tables found in database:', tables);
    
    // If we don't find any tables, try an alternative approach
    if (tables.length === 0) {
      console.log('No tables found with standard query, trying alternative approaches...');
      
      // Try a different query for SQLite databases
      try {
        const altTableResults = await executeSql(db, "SELECT tbl_name FROM sqlite_master WHERE type='table'", []);
        const altTableData = getRowsData(altTableResults);
        
        for (const row of altTableData) {
          if (row.tbl_name && !tables.includes(row.tbl_name)) {
            tables.push(row.tbl_name);
          }
        }
        
        console.log('Tables found with alternative query:', tables);
      } catch (altError) {
        console.error('Error with alternative table query:', altError);
      }
      
      // If we still don't have tables, try brute force approach by checking for expected tables directly
      if (tables.length === 0) {
        console.log('Still no tables found, trying direct table existence checks...');
        
        // Try some common Bible database table patterns
        const commonPrefixes = ['kjv', 'bible', 'asv', 'niv', 'esv', ''];
        
        for (const prefix of commonPrefixes) {
          const prefixWithUnderscore = prefix ? `${prefix}_` : '';
          
          try {
            // Check if books table exists
            const booksTableName = `${prefixWithUnderscore}books`;
            const bookCheckResult = await executeSql(
              db, 
              `SELECT 1 FROM ${booksTableName} LIMIT 1`,
              []
            ).catch(() => null);
            
            if (bookCheckResult) {
              console.log(`Found books table: ${booksTableName}`);
              tables.push(booksTableName);
            }
          } catch (e) {
            // Table doesn't exist, continue checking
          }
          
          try {
            // Check if verses table exists
            const versesTableName = `${prefixWithUnderscore}verses`;
            const verseCheckResult = await executeSql(
              db,
              `SELECT 1 FROM ${versesTableName} LIMIT 1`,
              []
            ).catch(() => null);
            
            if (verseCheckResult) {
              console.log(`Found verses table: ${versesTableName}`);
              tables.push(versesTableName);
            }
          } catch (e) {
            // Table doesn't exist, continue checking
          }
        }
      }
    }
    
    // Check table structure for each potential Bible books table
    let booksTable: string | null = null;
    let versesTable: string | null = null;
    let translation: string | null = null;
    
    // First try to identify using the <translation>_books and <translation>_verses pattern
    for (const table of tables) {
      if (table.endsWith('_books')) {
        const potentialTranslation = table.replace('_books', '');
        const potentialVersesTable = `${potentialTranslation}_verses`;
        
        if (tables.includes(potentialVersesTable)) {
          booksTable = table;
          versesTable = potentialVersesTable;
          translation = potentialTranslation;
          break;
        }
      }
    }
    
    // If we couldn't find matching tables, try more lenient matching
    if (!booksTable || !versesTable) {
      // Find any table with "book" in the name
      const booksTables = tables.filter(t => t.includes('book'));
      if (booksTables.length > 0) {
        booksTable = booksTables[0];
      }
      
      // Find any table with "verse" in the name
      const versesTables = tables.filter(t => t.includes('verse'));
      if (versesTables.length > 0) {
        versesTable = versesTables[0];
      }
      
      // Extract translation from either table
      if (booksTable && booksTable.includes('_')) {
        translation = booksTable.split('_')[0];
      } else if (versesTable && versesTable.includes('_')) {
        translation = versesTable.split('_')[0];
      } else {
        translation = 'kjv'; // Default to KJV if we can't detect
      }
    }
    
    // If we still couldn't find the tables, try direct schema analysis
    if (!booksTable || !versesTable) {
      console.log('Could not identify tables by name, attempting schema analysis...');
      
      for (const table of tables) {
        try {
          // Get table schema
          const schemaQuery = `PRAGMA table_info(${table})`;
          const schemaResults = await executeSql(db, schemaQuery, []);
          
          const columns: string[] = [];
          if (schemaResults.rows && schemaResults.rows._array) {
            for (let i = 0; i < schemaResults.rows._array.length; i++) {
              columns.push(schemaResults.rows._array[i].name);
            }
          } else if (schemaResults.rows && schemaResults.rows.item) {
            for (let i = 0; i < schemaResults.rows.length; i++) {
              columns.push(schemaResults.rows.item(i).name);
            }
          }
          
          console.log(`Table ${table} has columns:`, columns);
          
          // Check if this is likely a books table
          if (!booksTable && 
              columns.includes('id') && 
              columns.includes('name') &&
              columns.length <= 5) { // Books tables are typically simple
            booksTable = table;
            console.log(`Identified ${table} as likely books table`);
          }
          
          // Check if this is likely a verses table
          if (!versesTable && 
              columns.includes('book_id') && 
              columns.includes('chapter') && 
              columns.includes('verse') && 
              columns.includes('text')) {
            versesTable = table;
            console.log(`Identified ${table} as likely verses table`);
          }
        } catch (error) {
          console.error(`Error analyzing schema for table ${table}:`, error);
        }
      }
    }
    
    // If we found a structure, return it
    if (booksTable && versesTable) {
      console.log(`Identified database structure: translation=${translation}, books=${booksTable}, verses=${versesTable}`);
      return { booksTable, versesTable, translation };
    }
    
    // If we couldn't find any tables, give up and use our defaults
    console.log('Could not identify book or verse tables in database');
    return { 
      booksTable: 'kjv_books', 
      versesTable: 'kjv_verses', 
      translation: 'kjv' 
    };
    
  } catch (error) {
    console.error('Error detecting database structure:', error);
    // Default to standard KJV tables as fallback
    return { 
      booksTable: 'kjv_books', 
      versesTable: 'kjv_verses', 
      translation: 'kjv' 
    };
  }
};

// Updated function to handle direct data insertion when needed
export const insertDirectBibleData = async (): Promise<boolean> => {
  try {
    console.log('Inserting direct Bible data...');
    const db = await getDatabase();
    
    // Create our standard tables if they don't exist
    await createBibleTables(db);
    
    // Insert default books
    await insertCompleteBibleBooks(db);
    
    // Insert at least essential verses to ensure basic functionality
    await insertEssentialVerses(db);
    
    // Success
    console.log('Successfully inserted direct Bible data');
    return true;
  } catch (error) {
    console.error('Error inserting direct Bible data:', error);
    return false;
  }
};

// Helper function to extract database from raw KJV database file
export const extractRawDatabaseData = async (): Promise<boolean> => {
  try {
    console.log('Attempting raw database extraction...');
    const fileSystem = FileSystem as any;
    const asset = Asset.fromModule(require('../assets/KJV.db'));
    await asset.downloadAsync();
    
    const tempPath = `${fileSystem.documentDirectory}raw_extract_temp.db`;
    console.log(`Copying asset to ${tempPath}...`);
    
    // Copy the asset to a temporary file
    await fileSystem.copyAsync({
      from: asset.localUri!,
      to: tempPath
    });
    
    // Try to open it with different approaches
    let tempDb: Database | null = null;
    try {
      // Use the platform-specific approach to open database
      if (Platform.OS === 'ios') {
        tempDb = await openBibleDatabase(tempDbPath);
      } else {
        // For Android
        tempDb = await openBibleDatabase(tempDbName);
      }
      console.log('Successfully opened database with SQLite.openDatabase');
    } catch (error) {
      console.error('Error opening database with SQLite.openDatabase:', error);
      return false;
    }
    
    // Identify tables with a direct query to get bytes from the file
    try {
      console.log('Analyzing database file structure...');
      // Use a simple query to verify the database is usable
      const tableCheckQuery = "SELECT name FROM sqlite_master WHERE type='table' LIMIT 10";
      const tableResults = await executeSql(tempDb!, tableCheckQuery, []);
      
      const tableData = getRowsData(tableResults);
      const tables = tableData.map(row => row.name).filter(Boolean);
      
      console.log('Raw extraction found tables:', tables);
      
      // Close the database
      if (tempDb) {
        await tempDb.closeAsync();
      }
      
      // Clean up the temporary file
      await fileSystem.deleteAsync(tempPath, { idempotent: true });
      
      // Success if we found tables
      return tables.length > 0;
    } catch (error) {
      console.error('Error analyzing database file structure:', error);
      
      // Clean up
      if (tempDb) {
        try {
          await tempDb.closeAsync();
        } catch (e) {}
      }
      await fileSystem.deleteAsync(tempPath, { idempotent: true });
      
      return false;
    }
  } catch (error) {
    console.error('Error in raw database extraction:', error);
    return false;
  }
};

// Completely revamped function to populate database from asset with best Expo practices
export const populateFromAsset = async (): Promise<boolean> => {
  try {
    console.log('Starting to populate database from asset...');
    
    // Ensure the database directory exists
    await FileSystem.makeDirectoryAsync(FileSystem.documentDirectory!, { intermediates: true }).catch(() => {});
    
    // Database paths
    const tempDbName = 'temp_bible.db';
    const tempDbPath = `${FileSystem.documentDirectory}${tempDbName}`;
    
    // Delete any existing temp database
    await FileSystem.deleteAsync(tempDbPath, { idempotent: true }).catch(() => {});
    
    console.log('Ensuring database asset is prepared...');
    
    try {
      // Load the database asset
      const asset = Asset.fromModule(require(DATABASE_ASSET_PATH));
      await asset.downloadAsync();
      
      if (!asset.localUri) {
        throw new Error('Failed to get local URI for asset');
      }
      
      console.log('Asset ready at:', asset.localUri);
      
      // Copy the asset to the document directory so we can open it
      await FileSystem.copyAsync({
        from: asset.localUri,
        to: tempDbPath
      });
      
      let tempDb: Database | null = null;
      
      try {
        // Use the platform-specific approach to open database
        if (Platform.OS === 'ios') {
          tempDb = await openBibleDatabase(tempDbPath);
        } else {
          // For Android
          tempDb = await openBibleDatabase(tempDbName);
        }
        console.log('Successfully opened database with SQLite.openDatabase');
        
        // Check if the temp database has the tables we need
        const hasCorrectStructure = await detectDatabaseStructure(tempDb);
        if (!hasCorrectStructure.booksTable || !hasCorrectStructure.versesTable) {
          throw new Error('Database asset does not have the expected structure');
        }
        
        // Close the temp database
        if (tempDb) await tempDb.closeAsync();
        
        // Copy the temp database to our final location
        await FileSystem.copyAsync({
          from: tempDbPath,
          to: `${FileSystem.documentDirectory}${DATABASE_NAME}`
        });
        
        console.log('Database asset copied successfully');
        
        // Re-open the database
        db = await openBibleDatabase(DATABASE_NAME);
        
        // Verify database integrity
        const isIntact = await verifyDatabaseIntegrity(db);
        if (!isIntact) {
          throw new Error('Bible database integrity check failed');
        }
        
        return true;
      } catch (dbError) {
        console.error('Error working with database:', dbError);
        
        // Clean up
        if (tempDb) await tempDb.closeAsync();
        
        return false;
      }
    } catch (assetError) {
      console.error('Error populating database from asset:', assetError);
      
      // Try a different approach: create DB at the final location directly
      console.log('Opening database...');
      try {
        let tempDb: Database;
        
        // For iOS, use the full path. For Android, just the filename
        if (Platform.OS === 'ios') {
          tempDb = await openBibleDatabase(tempDbPath);
        } else {
          tempDb = await openBibleDatabase(tempDbName);
        }
        
        // Create and populate the database directly
        await createBibleTables(tempDb);
        
        // Close the temp database
        await tempDb.closeAsync();
        
        // Copy to final location
        await FileSystem.copyAsync({
          from: tempDbPath,
          to: `${FileSystem.documentDirectory}${DATABASE_NAME}`
        });
        
        return true;
      } catch (createError) {
        console.error('Error creating database from scratch:', createError);
        return false;
      }
    }
  } catch (error) {
    console.error('Error in populateFromAsset:', error);
    return false;
  }
};

// Helper function to create database tables
export const createBibleTables = async (db: Database): Promise<void> => {
  console.log('Creating Bible tables individually with direct API calls...');
  
  // Create the books table
  try {
    console.log('Creating kjv_books table...');
    await db.runAsync(
      `CREATE TABLE IF NOT EXISTS kjv_books (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL
      )`
    );
    console.log('kjv_books table created successfully');
  } catch (booksError) {
    console.error('Error creating books table:', booksError);
    // Continue anyway to try creating verses table
  }
  
  // Create the verses table
  try {
    console.log('Creating kjv_verses table...');
    await db.runAsync(
      `CREATE TABLE IF NOT EXISTS kjv_verses (
        id INTEGER PRIMARY KEY,
        book_id INTEGER NOT NULL,
        chapter INTEGER NOT NULL,
        verse INTEGER NOT NULL,
        text TEXT NOT NULL,
        FOREIGN KEY (book_id) REFERENCES kjv_books (id)
      )`
    );
    console.log('kjv_verses table created successfully');
  } catch (versesError) {
    console.error('Error creating verses table:', versesError);
  }
  
  // Create indexes
  try {
    console.log('Creating book_chapter index...');
    await db.runAsync(
      `CREATE INDEX IF NOT EXISTS idx_verses_book_chapter ON kjv_verses (book_id, chapter)`
    );
    
    console.log('Creating book_id index...');
    await db.runAsync(
      `CREATE INDEX IF NOT EXISTS idx_verses_book_id ON kjv_verses (book_id)`
    );
    
    console.log('All indexes created successfully');
  } catch (indexError) {
    console.error('Error creating indexes:', indexError);
  }
  
  // Verify tables were created
  try {
    const result = await db.getAllAsync<{ name: string }>(
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='kjv_books' OR name='kjv_verses')"
    );
    
    const tables = result.map((row) => row.name);
    console.log('Tables verified after creation:', tables);
  } catch (verifyError) {
    console.error('Error verifying tables:', verifyError);
  }
};

/**
 * Insert complete Bible book list into database
 */
// Function moved to exported version below


/**
 * Insert essential verses into database
 */
// Function moved to exported version below


/**
 * Get a verse by book name, chapter, and verse number
 */
export const getVerse = async (bookName: string, chapter: number, verse: number): Promise<Scripture | null> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT b.name as book_name, v.chapter, v.verse, v.text
       FROM KJV_verses v
       JOIN KJV_books b ON v.book_id = b.id
       WHERE b.name = ? AND v.chapter = ? AND v.verse = ?`,
      [bookName, chapter, verse]
    );
    
    if (result && result.rows && result.rows.length > 0) {
      return result.rows._array[0] as Scripture;
    }
    return null;
  } catch (error) {
    console.error('Error getting verse:', error);
    return null;
  }
};

/**
 * Get all verses for a chapter
 */
export const getChapter = async (bookName: string, chapter: number): Promise<Scripture[]> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT b.name as book_name, v.chapter, v.verse, v.text
       FROM KJV_verses v
       JOIN KJV_books b ON v.book_id = b.id
       WHERE b.name = ? AND v.chapter = ?
       ORDER BY v.verse`,
      [bookName, chapter]
    );
    
    if (result && result.rows) {
      return result.rows._array as Scripture[];
    }
    return [];
  } catch (error) {
    console.error('Error getting chapter:', error);
    return [];
  }
};

/**
 * Get a random verse from the database
 */
export const getRandomVerse = async (): Promise<Scripture | null> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT b.name as book_name, v.chapter, v.verse, v.text
       FROM KJV_verses v
       JOIN KJV_books b ON v.book_id = b.id
       ORDER BY RANDOM() LIMIT 1`
    );
    
    if (result && result.rows && result.rows.length > 0) {
      return result.rows._array[0] as Scripture;
    }
    return null;
  } catch (error) {
    console.error('Error getting random verse:', error);
    return null;
  }
};

/**
 * Search for verses containing the search text
 */
export const searchVerses = async (searchText: string, limit: number = 20): Promise<Scripture[]> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT b.name as book_name, v.chapter, v.verse, v.text
       FROM KJV_verses v
       JOIN KJV_books b ON v.book_id = b.id
       WHERE v.text LIKE ?
       ORDER BY b.id, v.chapter, v.verse
       LIMIT ?`,
      [`%${searchText}%`, limit]
    );
    
    if (result && result.rows) {
      return result.rows._array as Scripture[];
    }
    return [];
  } catch (error) {
    console.error('Error searching verses:', error);
    return [];
  }
};

/**
 * Get all Bible books
 */
export const getAllBooks = async (): Promise<BibleBook[]> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      'SELECT id, name FROM KJV_books ORDER BY id'
    );
    
    if (result && result.rows) {
      return result.rows._array as BibleBook[];
    }
    return [];
  } catch (error) {
    console.error('Error getting books:', error);
    return [];
  }
};

/**
 * Get chapter count for a book
 */
export const getChapterCount = async (bookId: number): Promise<number> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT MAX(chapter) as max_chapter FROM KJV_verses WHERE book_id = ?`,
      [bookId]
    );
    
    if (result && result.rows && result.rows.length > 0) {
      return result.rows._array[0].max_chapter || 0;
    }
    return 0;
  } catch (error) {
    console.error('Error getting chapter count:', error);
    return 0;
  }
};

/**
 * Get verses for a specific book and chapter
 */
export const getVerses = async (bookId: number, chapter: number): Promise<BibleVerse[]> => {
  try {
    const db = await openBibleDatabase();
    const result = await executeSql(
      db,
      `SELECT v.*, b.name as book_name
       FROM KJV_verses v
       JOIN KJV_books b ON v.book_id = b.id
       WHERE v.book_id = ? AND v.chapter = ?
       ORDER BY v.verse`,
      [bookId, chapter]
    );
    
    if (result && result.rows) {
      return result.rows._array as BibleVerse[];
    }
    return [];
  } catch (error) {
    console.error('Error getting verses:', error);
    return [];
  }
};

/**
 * Diagnose database issues and attempt repair
 */
export const diagnoseBibleDatabase = async (): Promise<string> => {
  try {
    // Get database instance
    const dbInstance = await getDatabase(); // Renamed to avoid shadowing the global db variable
    
    // Check if tables exist
    const tablesResult = await executeSql(
      dbInstance,
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='kjv_books' OR name='kjv_verses')",
      []
    );
    
    const tables = tablesResult.rows._array.map((row: { name: string }) => row.name);
    if (!tables.includes('kjv_books') || !tables.includes('kjv_verses')) {
      // Tables don't exist, try emergency init
      console.log('Essential tables missing, attempting emergency initialization...');
      const emergencySuccess = await emergencyDatabaseInit();
      
      if (emergencySuccess) {
        return 'Missing tables repaired with emergency data. Limited content available.';
      }
      return 'Missing essential tables. Will attempt to create them.';
    }
    
    // Check book count
    const booksResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_books', []);
    const booksCount = booksResult.rows._array[0].count;
    
    // Check verse count
    const versesResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_verses', []);
    const versesCount = versesResult.rows._array[0].count;
    
    if (booksCount < 66 || versesCount < 100) {
      // If we don't have all 66 books or at least 100 verses, try emergency init
      console.log(`Database underpopulated: ${booksCount} books, ${versesCount} verses`);
      
      // Try emergency init first as it's more reliable
      console.log('Using emergency initialization for underpopulated database...');
      const emergencySuccess = await emergencyDatabaseInit();
      
      if (emergencySuccess) {
        // Check counts again
        const newBooksResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_books', []);
        const newBooksCount = newBooksResult.rows._array[0].count;
        
        const newVersesResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_verses', []);
        const newVersesCount = newVersesResult.rows._array[0].count;
        
        return `Database repaired with emergency data. Now has ${newBooksCount} books and ${newVersesCount} verses. Limited content available.`;
      }
      
      // If emergency init failed, try asset-based population
      const populated = await populateFromAsset();
      
      if (populated) {
        // Check counts again
        const newBooksResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_books', []);
        const newBooksCount = newBooksResult.rows._array[0].count;
        
        const newVersesResult = await executeSql(dbInstance, 'SELECT COUNT(*) as count FROM kjv_verses', []);
        const newVersesCount = newVersesResult.rows._array[0].count;
        
        return `Database repaired. Now has ${newBooksCount} books and ${newVersesCount} verses.`;
      } else {
        return 'Failed to populate database from asset. Try reinstalling the app.';
      }
    }
    
    return `Database looks healthy: ${booksCount} books and ${versesCount} verses.`;
  } catch (error) {
    console.error('Error diagnosing database:', error);
    
    // Try emergency init if diagnosis failed
    try {
      console.log('Error during diagnosis, trying emergency initialization...');
      const emergencySuccess = await emergencyDatabaseInit();
      
      if (emergencySuccess) {
        return 'Database repaired with emergency data after diagnosis error. Limited content available.';
      }
      
      return 'Failed to repair database after diagnosis error. Try reinstalling the app.';
    } catch (emergencyError) {
      console.error('Error with emergency initialization:', emergencyError);
      return 'Multiple database errors detected. Please reinstall the app.';
    }
  }
};

/**
 * Force reloading the Bible database from the asset
 */
export const forceReloadBibleDatabase = async (): Promise<boolean> => {
  try {
    // Get database instance
    const db = await getDatabase();
    
    console.log('Dropping existing Bible tables...');
    
    // Drop existing tables
    await executeSql(db, 'DROP TABLE IF EXISTS kjv_verses', []);
    await executeSql(db, 'DROP TABLE IF EXISTS kjv_books', []);
    
    console.log('Recreating tables and populating from asset...');
    
    // Populate from asset
    const result = await populateFromAsset();
    
    if (result) {
      console.log('Database successfully reloaded from asset.');
    } else {
      console.error('Failed to reload database from asset.');
    }
    
    return result;
  } catch (error) {
    console.error('Error reloading database:', error);
    return false;
  }
};

// Insert complete list of Bible books
export const insertCompleteBibleBooks = async (db: Database): Promise<void> => {
  try {
    console.log('Inserting complete list of Bible books...');
    const books = [
      { id: 1, name: 'Genesis' },
      { id: 2, name: 'Exodus' },
      { id: 3, name: 'Leviticus' },
      { id: 4, name: 'Numbers' },
      { id: 5, name: 'Deuteronomy' },
      { id: 6, name: 'Joshua' },
      { id: 7, name: 'Judges' },
      { id: 8, name: 'Ruth' },
      { id: 9, name: 'I Samuel' },
      { id: 10, name: 'II Samuel' },
      { id: 11, name: 'I Kings' },
      { id: 12, name: 'II Kings' },
      { id: 13, name: 'I Chronicles' },
      { id: 14, name: 'II Chronicles' },
      { id: 15, name: 'Ezra' },
      { id: 16, name: 'Nehemiah' },
      { id: 17, name: 'Esther' },
      { id: 18, name: 'Job' },
      { id: 19, name: 'Psalms' },
      { id: 20, name: 'Proverbs' },
      { id: 21, name: 'Ecclesiastes' },
      { id: 22, name: 'Song of Solomon' },
      { id: 23, name: 'Isaiah' },
      { id: 24, name: 'Jeremiah' },
      { id: 25, name: 'Lamentations' },
      { id: 26, name: 'Ezekiel' },
      { id: 27, name: 'Daniel' },
      { id: 28, name: 'Hosea' },
      { id: 29, name: 'Joel' },
      { id: 30, name: 'Amos' },
      { id: 31, name: 'Obadiah' },
      { id: 32, name: 'Jonah' },
      { id: 33, name: 'Micah' },
      { id: 34, name: 'Nahum' },
      { id: 35, name: 'Habakkuk' },
      { id: 36, name: 'Zephaniah' },
      { id: 37, name: 'Haggai' },
      { id: 38, name: 'Zechariah' },
      { id: 39, name: 'Malachi' },
      { id: 40, name: 'Matthew' },
      { id: 41, name: 'Mark' },
      { id: 42, name: 'Luke' },
      { id: 43, name: 'John' },
      { id: 44, name: 'Acts' },
      { id: 45, name: 'Romans' },
      { id: 46, name: 'I Corinthians' },
      { id: 47, name: 'II Corinthians' },
      { id: 48, name: 'Galatians' },
      { id: 49, name: 'Ephesians' },
      { id: 50, name: 'Philippians' },
      { id: 51, name: 'Colossians' },
      { id: 52, name: 'I Thessalonians' },
      { id: 53, name: 'II Thessalonians' },
      { id: 54, name: 'I Timothy' },
      { id: 55, name: 'II Timothy' },
      { id: 56, name: 'Titus' },
      { id: 57, name: 'Philemon' },
      { id: 58, name: 'Hebrews' },
      { id: 59, name: 'James' },
      { id: 60, name: 'I Peter' },
      { id: 61, name: 'II Peter' },
      { id: 62, name: 'I John' },
      { id: 63, name: 'II John' },
      { id: 64, name: 'III John' },
      { id: 65, name: 'Jude' },
      { id: 66, name: 'Revelation' }
    ];
    
    // Delete any existing books
    await executeSql(db, 'DELETE FROM kjv_books', []);
    
    // Insert books
    for (const book of books) {
      await executeSql(
        db,
        'INSERT INTO kjv_books (id, name) VALUES (?, ?)',
        [book.id, book.name]
      );
    }
    
    console.log('Successfully inserted all 66 Bible books');
    
  } catch (error) {
    console.error('Error inserting Bible books:', error);
    throw error;
  }
};

// Insert essential verses
export const insertEssentialVerses = async (db: Database): Promise<void> => {
  try {
    console.log(`Inserting ${essentialVerses.length} essential verses...`);
    
    // Delete any existing verses
    await executeSql(db, 'DELETE FROM kjv_verses', []);
    
    // Insert essential verses
    for (const verse of essentialVerses) {
      await executeSql(
        db,
        'INSERT INTO kjv_verses (id, book_id, chapter, verse, text) VALUES (?, ?, ?, ?, ?)',
        [verse.id, verse.book_id, verse.chapter, verse.verse, verse.text]
      );
    }
    
    // Add some additional verses to make the app more usable
    const additionalVerses = [
      // Genesis 1:1-5
      { id: 200, book_id: 1, chapter: 1, verse: 1, text: 'In the beginning God created the heaven and the earth.' },
      { id: 201, book_id: 1, chapter: 1, verse: 2, text: 'And the earth was without form, and void; and darkness was upon the face of the deep. And the Spirit of God moved upon the face of the waters.' },
      { id: 202, book_id: 1, chapter: 1, verse: 3, text: 'And God said, Let there be light: and there was light.' },
      { id: 203, book_id: 1, chapter: 1, verse: 4, text: 'And God saw the light, that it was good: and God divided the light from the darkness.' },
      { id: 204, book_id: 1, chapter: 1, verse: 5, text: 'And God called the light Day, and the darkness he called Night. And the evening and the morning were the first day.' },
      
      // John 1:1-5
      { id: 300, book_id: 43, chapter: 1, verse: 1, text: 'In the beginning was the Word, and the Word was with God, and the Word was God.' },
      { id: 301, book_id: 43, chapter: 1, verse: 2, text: 'The same was in the beginning with God.' },
      { id: 302, book_id: 43, chapter: 1, verse: 3, text: 'All things were made by him; and without him was not any thing made that was made.' },
      { id: 303, book_id: 43, chapter: 1, verse: 4, text: 'In him was life; and the life was the light of men.' },
      { id: 304, book_id: 43, chapter: 1, verse: 5, text: 'And the light shineth in darkness; and the darkness comprehended it not.' },
      
      // Romans 8:28-31
      { id: 400, book_id: 45, chapter: 8, verse: 28, text: 'And we know that all things work together for good to them that love God, to them who are the called according to his purpose.' },
      { id: 401, book_id: 45, chapter: 8, verse: 29, text: 'For whom he did foreknow, he also did predestinate to be conformed to the image of his Son, that he might be the firstborn among many brethren.' },
      { id: 402, book_id: 45, chapter: 8, verse: 30, text: 'Moreover whom he did predestinate, them he also called: and whom he called, them he also justified: and whom he justified, them he also glorified.' },
      { id: 403, book_id: 45, chapter: 8, verse: 31, text: 'What shall we then say to these things? If God be for us, who can be against us?' },
      
      // Philippians 4:6-8
      { id: 500, book_id: 50, chapter: 4, verse: 6, text: 'Be careful for nothing; but in every thing by prayer and supplication with thanksgiving let your requests be made known unto God.' },
      { id: 501, book_id: 50, chapter: 4, verse: 7, text: 'And the peace of God, which passeth all understanding, shall keep your hearts and minds through Christ Jesus.' },
      { id: 502, book_id: 50, chapter: 4, verse: 8, text: 'Finally, brethren, whatsoever things are true, whatsoever things are honest, whatsoever things are just, whatsoever things are pure, whatsoever things are lovely, whatsoever things are of good report; if there be any virtue, and if there be any praise, think on these things.' },
      
      // Psalm 23 - complete
      { id: 600, book_id: 19, chapter: 23, verse: 1, text: 'The LORD is my shepherd; I shall not want.' },
      { id: 601, book_id: 19, chapter: 23, verse: 2, text: 'He maketh me to lie down in green pastures: he leadeth me beside the still waters.' },
      { id: 602, book_id: 19, chapter: 23, verse: 3, text: 'He restoreth my soul: he leadeth me in the paths of righteousness for his name\'s sake.' },
      { id: 603, book_id: 19, chapter: 23, verse: 4, text: 'Yea, though I walk through the valley of the shadow of death, I will fear no evil: for thou art with me; thy rod and thy staff they comfort me.' },
      { id: 604, book_id: 19, chapter: 23, verse: 5, text: 'Thou preparest a table before me in the presence of mine enemies: thou anointest my head with oil; my cup runneth over.' },
      { id: 605, book_id: 19, chapter: 23, verse: 6, text: 'Surely goodness and mercy shall follow me all the days of my life: and I will dwell in the house of the LORD for ever.' },
    ];
    
    // Insert additional verses
    for (const verse of additionalVerses) {
      await executeSql(
        db,
        'INSERT INTO kjv_verses (id, book_id, chapter, verse, text) VALUES (?, ?, ?, ?, ?)',
        [verse.id, verse.book_id, verse.chapter, verse.verse, verse.text]
      );
    }
    
    console.log(`Inserted ${essentialVerses.length + additionalVerses.length} total verses`);
    
  } catch (error) {
    console.error('Error inserting essential verses:', error);
    throw error;
  }
};

// A complete emergency database initialization with minimal required data
export const emergencyDatabaseInit = async (): Promise<boolean> => {
  console.log('EMERGENCY DATABASE INITIALIZATION');
  
  try {
    // Get database instance
    const db = await openBibleDatabase();
    
    // Verify tables and data after initialization
    const result = await executeSql(
      db,
      "SELECT name FROM sqlite_master WHERE type='table' AND (name='KJV_books' OR name='KJV_verses')"
    );
    
    const tables = result.rows._array.map(row => row.name);
    if (tables.includes('KJV_books') && tables.includes('KJV_verses')) {
      // Check data counts
      const countResult = await executeSql(
        db,
        "SELECT (SELECT COUNT(*) FROM KJV_books) as book_count, (SELECT COUNT(*) FROM KJV_verses) as verse_count"
      );
      
      const { book_count, verse_count } = countResult.rows._array[0];
      console.log(`Emergency database contains: ${book_count} books, ${verse_count} verses`);
      
      if (book_count >= 66 && verse_count >= 31000) {
        return true; // Database is good
      }
    }
    
    // If we get here, we need to reinitialize from asset
    console.log('Attempting to reload from KJV.db asset...');
    const success = await initializeDatabaseFromAsset();
    
    if (success) {
      console.log('Successfully reinitialized from KJV.db asset');
      return true;
    }
    
    console.error('Failed to initialize database from asset');
    return false;
  } catch (error) {
    console.error('Error in emergencyDatabaseInit:', error);
    return false;
  }
};